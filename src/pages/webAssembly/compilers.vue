<template>
	<div class="markdown-body">
<h1 id="toc_0">just-in-time编译器速成教程[译]</h1>

<p>这是WebAssembly系列的第二部分。<br/>
JavaScript开始很慢，但得益于JIT，变得快起来。但是JIT是怎样工作的呢？</p>

<h2 id="toc_1">JavaScript是怎样在浏览器中运行的</h2>

<p>当你作为一个开发者添加JavaScript到页面时，随之产生一个目的和一个问题。</p>

<p>目的：你想告诉计算机去做什么。<br/>
问题：你和计算机说不同的语言。</p>

<p>你说人类语言，而计算机说机器语言。即使你不认为JavaScript或其他高级语言是人类语言，但他们其实是。他们被设计为可被人类识别，而不是机器。</p>

<p>所以JavaScript引擎的工作是把你的人类语言转换为机器能识别的东西。</p>

<p>我认为这有点像电影<a href="https://en.wikipedia.org/wiki/Arrival_(film)">降临（Arrival）</a>,在里面你使用人类语言，而外星人尝试和你对话。<br/>
<img src="./../../img/02-01-alien03-500x286.png" alt="02-01-alien03-500x286"/>￼<br/>
在这部电影里，人类和外星人不是逐字转化。两个群体有不同的思考文字的方式。人类和机器也一样(我会在下篇文章里进行更多阐述)。</p>

<p>所以转化是怎样发生的呢？</p>

<p>在编程中，通常有2种转化成机器语言的方式。你可以使用interpreter(解释器)或compiler(编译器)。</p>

<p>使用解释器时，代码是转化一行执行一行，飞速进行。<br/>
<img src="./../../img/02-02-interp02-500x291.png" alt="02-02-interp02-500x291"/>￼</p>

<p>另一方面，编译器就不是这样快速的转化过程。它会先转化好，然后写下来。<br/>
<img src="./../../img/02-03-compile02-500x297.png" alt="02-03-compile02-500x297"/>￼</p>

<p>这两种转化的方法都有利弊。</p>

<h3 id="toc_2">解释器的利与弊</h3>

<p>解释器能很快跑起来。你不需要经历整个编译步骤就能让你的代码跑起来。你只需要转化好第一行代码，转化后这行的代码就跑起来了。<br/>
得益于此，解释器看上去好像是为JavaScript量身打造的。对web开发人员来说，能够快速让他们的代码跑起来是很重要的。<br/>
这也是为什么浏览器一开始采用JavaScript解释器。<br/>
但当你多次跑同一段代码时，弊端也显现出来。比如，在一个循环中的情况。这种情况下，你必须不断做重复的转化。</p>

<h3 id="toc_3">编译器的利与弊</h3>

<p>编译器有相对的权衡。</p>

<p>它需要多一点的时间才能跑起来因为它首先需要经过编译步骤.但循环中的代码跑的更快些，因为它不需要每循环一次，就转换一次。</p>

<p>另一个区别是编译器需要多一点的时间去查看和编辑代码为了使它跑的更快些。这些编辑操作叫做优化。</p>

<p>解释器在执行之间完成它的工作，所以它没办法花很多时间在转换阶段对代码做优化。</p>

<h2 id="toc_4">Just-in-time编译器：两全其美的结果</h2>

<p>作为一个去掉解释器的低效率缺点（每当解释器在重复转换代码）并且在循环浏览时混入编译器。</p>

<p>不同的浏览器实现的方式有略微区别，但基本理念是一样的。他们在JavaScript引擎里加了一个新东西，叫做监视器（也叫分析器）。监视器在代码运行时观察代码，对代码运行次数和使用的类型做记录。</p>

<p>首先，监视器通过解释器跑一边代码。<br/>
<img src="./../../img/02-04-jit02-500x365.png" alt="02-04-jit02-500x365"/>￼<br/>
监视器观察代码的执行过程，标志那些应被解释器执行的代码。</p>

<p>如果一段代码跑了几次，那这段代码叫warm.如果跑了很多次，那么它叫hot.</p>

<h3 id="toc_5">基线编译器</h3>

<p>当函数开始变得warm, JIT会发送它去进行编译。然后JIT会保存编译结果。<br/>
<img src="./../../img/02-05-jit06-500x368.png" alt="02-05-jit06-500x368"/>￼<br/>
监视器看到有函数被调用多次，标志这个函数应该被送到基线编译器去创建一个存根。</p>

<p>该函数的每一行都被编译保存到一个存根。存根是被行数和变量类型索引的（我会在后面展示为什么这很重要）。如果监视器看到执行过程中碰到带相同变量类型的相同代码，它会去找对应的编译版本。</p>

<p>这能提高执行的速度。但就像我说的，编译器能够做的更多。它可以花些时间去计算出最有效的方式去做些事情，比如优化。</p>

<p>基线编译器会做些优化（我在下面给出了例子）。它不会想要花太多时间，尽管，因为它不想要让执行挂起太久。</p>

<p>不管怎样，如果代码真的hot,并且跑了很多次，那么它值得花些额外的时间做优化。</p>

<h3 id="toc_6">优化的编译器</h3>

<p>当一部分代码非常hot时，编译器会发送它到优化的编译器。这样会创建一个更快速的函数版本，并保存起来。</p>

<p><img src="./../../img/02-06-jit09-500x365.png" alt="02-06-jit09-500x365"/>￼<br/>
监视器看到函数被调用的次数超出常规，标志它应该被充分地优化。</p>

<p>为了创建更快速的代码，优化编译器必须做一些假设。</p>

<p>比如，当它假定所有被特定的构造器创建的对象有同样的形状，就是说，他们总是有着同样的属性名，这些属性以同样的顺序被添加,这可以作为一个切入点。</p>

<p>优化编译器使用监视器在观察代码执行过程中收集到的信息去做判断。如果之前一些代码为真在之前所有的循环中，那它下面的循环中也被判定为真。</p>

<p>当然涉及JavaScript时，没有任何保证可言。你可能有99个有相同形状的对象，但第100个可能少了一个属性。</p>

<p>所以编译好的代码需要在执行前检查下来看看假定是否是正当的。如果他们是，那编译好的代码就去执行。如果不是，那JIT承担它做了错误的假设的事实，并丢弃优化的代码。<br/>
<img src="./../../img/02-07-jit11-500x361.png" alt="02-07-jit11-500x361"/>￼<br/>
监视器看到类型不符合期望，通知回到解释器。优化器扔掉优化的代码。</p>

<p>执行回到解释器或基线编译版本。这个过程叫做去优化或者跳伞。</p>

<p>通常优化编译器会使代码跑的更快，但有些时候他们会导致无法预料的性能问题。如果你的代码持续被优化和去优化，它会比执行基线优化版本更慢一点。</p>

<p>大多数浏览器加了限制来摆脱优化/去优化循环，当这些循环发生时。如果JIT尝试了很多次比如说10次在优化上，并且持续丢弃，那么它不会再去尝试对这段代码做优化。</p>

<h3 id="toc_7">一个优化例子：类型特殊化</h3>

<p>有许多不同类型的优化，但我会探究下其中一个类型这样你能认识到优化是如何发生的。最具分量的优化中，类型特殊化尤为重要，在优化编译器中，所以我就来说说它吧。</p>

<p>JavaScript使用的动态类型系统需要做一点额外的工作在运行的时候。比如，思量下下面的代码：<br/>
<code><br/>
function arraySum(arr) {<br/>
  var sum = 0;<br/>
  for (var i = 0; i &lt; arr.length; i++) {<br/>
    sum += arr[i];<br/>
  }<br/>
}<br/>
</code></p>

<p>+=的步骤在循环里看着简单。看上去，你只需要一步就能完成计算操作，但因为动态类型，他会比你想的多走一步。</p>

<p>我们假定arr是一个包含100个整数的数组。一旦代码活跃起来，基线编译器会为函数中的每个操作创建一个存根。所以会有一个对应sum += arr[i]的存根，这个存根会处理+=操作(作为整数相加)。</p>

<p>不管怎样，sum和arr[i]没有保证是整数。因为在JavaScript中类型是动态的，所以在后续的循环中会有一个可能，arr[i]会变成一个字符串。整数相加和字符串拼接是两种不同的操作，所以他们会转换成完全不同的机器码。</p>

<p>JIT处理这种情况的方式是通过编译多种基线存根。如果一段代码是单形态的（就是说，总是同种类型）它会有一个存根。如果它是多形态的（含有不同类型当再次执行该段代码时）,那它会为每个已经遇到的类型的结合操作准备一个存根。</p>

<p>这就意味着JIT会在选择对应的存根前，验证很多问题。</p>

<p><img src="./../../img/02-08-decision_tree01-500x257.png" alt="02-08-decision_tree01-500x257"/>￼</p>

<p>决策树展示了4个类型的检查</p>

<p>因为每行代码有自己的存根集合在基线编译器中，JIT需要持续检查类型，在每次代码行被执行的时候。所以即使是循环中的重复代码，它也会验证同样的问题。</p>

<p><img src="./../../img/02-09-jit_loop02-500x323.png" alt="02-09-jit_loop02-500x323"/>￼</p>

<p>代码循环的时候JIT会检查每次循环中使用的类型</p>

<p>代码会执行的快得多，如果JIT不需要重复这些检查。而且这其实是优化编译器要去做的事情。</p>

<p>在优化编译器中，整个函数变一起编译。类型检查被移除了，因此他们发生在循环之前。<br/>
<img src="./../../img/02-10-jit_loop02-500x318.png" alt="02-10-jit_loop02-500x318"/>￼<br/>
代码循环中的检查问题被提前了</p>

<p>一些JIT甚至更深层地优化了这个步骤。比如，Firefox中有专门针对整数数组的分类。如果arr数组是只包含整数的数组，那么JIT不需要检查arr[i]是不是整数。这意味着JIT在进入循环之前就做完了类型检查。</p>

<h2 id="toc_8">总结</h2>

<p>总而言之这就是JIT。它通过在运行时监测代码，发送hot代码去优化，使得JavaScript跑的更快。这导致很多JavaScript应用的性能得到了成倍的提升。</p>

<p>即使有了这些提升，JavaScript的性能仍然是不可预测的。为了得到更快的速度，JIT增加了一些开销在运行时，包括：</p>

<ul>
<li>优化和反优化</li>
<li>监视器用来统计和复原的内存</li>
<li>跳伞发生时的信息</li>
<li>用来保存基线和优化版本函数的内存</li>
</ul>

<p>这里仍有提升的空间：提前可以去掉，来使性能更可预测。这是WebAssembly的作用之一。</p>

<p>在下一章节中，我会对assembly以及compilers如何与它协作进行更多阐述。</p>

<blockquote>
<p>原文链接：<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a></p>
</blockquote>

	</div>
</template>
<script>
	export default {
		data(){
			return {}
		}
	}
</script>
